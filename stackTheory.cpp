/*
Стек работает по принципу "Первый пришёл, последний ушёл"
Пример – стопка тарелок, для того чтобы взять однe необходимо убрать остальные над ней

A4 <- A3 <- A2 <- A1 -- выглядит примерно так, основан на однонаправленном списке

Если мы вводим последовательность 1 2 3 4 5 в стек, то для распечатывания 3 необходимо распечатать 5 4 (именно в таком порядке)

В стеке нет индексов, нельзя обратиться к определённому элементу.
Но плюс – добавление и удаление элементов происходит за константное время
*/

//Работа через библиотеку
#include <stack>
//И класс stack <type>

/*
Синтаксис
stack <тип_данных> имя;

тип - любой необходимый: int, char, string и т.д.
*/

/*
Работа со стеком

Добавление элементов по одному (помыли тарелку, положили в стек, начали мыть новую)
имя_стека.push([та_самая_тарелка]) – добавить элемент в стек (В скобках указывается только здесь)

Доступ есть только к последнему добавленному элементу (только к верхней тарелке)
имя_стека.top() – посмотреть последний добавленный элемент

Удаление по одному элементу за раз (берём по одной тарелке, ма с вами всё-таки программисты, а не официанты)
имя_стека.pop() – удалить верхний элемент

Как достать N-й элемент? Снять все элементы перед ним.
Например, необходимо узнать, что нарисовано на третьей сверху тарелке.
Для этого мы снимаем вторую, для снятия котороой необходимо снять первую. Таким образом имя_стека.pop() и ещё раз имя_стека.pop()
Теперь нужная тарелка наверху и мы можем узнать рисунок на ней через имя_стека.top()

Как узнать размер стека? Методом .size() (Перед нами огромная стопка посуды, и мы не хотим считать по одному прибору, используем size)
имя_стека.size();
*/