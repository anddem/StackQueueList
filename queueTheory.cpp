/*
Очередь работает по принципу "Первый пришёл, первый ушёл"
Пример – очередь в магазине (ну или столовке)
A1 -> A2 -> A3 -> A4 -- примерно так выглядит, основана на однонаправленном списке

Если мы вводим последовательность 1 2 3 4 5 в очередь, то для вывода 3 необходимо распечатать 1 2 (именно в таком порядке)

В очереди нет индексов, нельзя обратиться к определённому элементу.
Но плюс – добавление и удаление элементов происходит за константное время
*/

//Работа через библиотеку
#include <queue>
//И класс queue <type>

/*
Синтаксис
queue <тип_данных> имя;

тип – любой необходимый: int, char, string и т.д.
*/

/*
Работа со очередью

Добавление элементов по одному (Приходишь в магазин, а там арм... очередь. Ну и встаёшь ПОСЛЕДНИМ)
имя_очереди.push([тут_ты_в_конце_очереди]) – добавить элемент в очередь (В скобках указывается только здесь)

Доступ есть первому и последнему элементу очереди (ты видишь конец очереди, и видишь начало)
имя_очереди.front() – посмотреть в начало (ближе к кабинету (imagination))
имя_очереди.back() – посмотреть в конец ("Кто в 205-й последний?")

Удаление по одному элементу за раз (в маке тоже будешь по одному обслуживать)
имя_очереди.pop() – удалить тот элемент, который был раньше (обслужили раньше т.к. пришёл раньше, тут тебе не больница и "только спросить")

Как достать N-й элемент? обслужить все элементы перед ним.
Например, необходимо узнать, какой заказ сделает третий человек от кассы.
Для этого мы обслуживаем первого, затем второго. Таким образом имя_очереди.pop() и ещё раз имя_очереди.pop()
Теперь нужный клиент около нас и мы можем начать разговор с вопроса "Здравствуйте, что будете заказывать" обратившись через имя_очереди.front()

Как узнать размер очереди? Методом .size() (Приходишь за проездным в сентябре, а там огромные очереди. Можешь сам посчитать, а можешь юзать size)
имя_очереди.size();
*/

/*
Очередь с приоритетом

Сидишь в очереди к врачу, никого не трогаешь, и тут приходит бабка с фразой "мне только спросить"
Тут возможны два исхода:
1. Вся очередь (и ты тоже) не ведётесь на грязную провокацию и оставляете её в конце
2. Бабка проходит перед тобой и вообще всем миром и вы не говорите ей ни слова

При варианте 1 всё ясно – стандартная очередь
При варианте 2 очередь становится не стандартной, а приоритетной

Синтаксис
priority_queue <тип> имя;

Строго говоря, это та же самая очередь, но отсортированная по убыванию значения стоящих в ней людей (у бабки приоритет выше, получается)

Ты не можешь узнать кто стоит впереди через имя_очереди.front(), а также спросить кто последний через имя_очереди.back()
Но можешь подняться над очередью и посмотреть на имя_очереди.top();

Остальное как всегда: имя_очереди.push([очередная_бабка]), имя_очереди.pop() и имя_очереди.size()
*/

/*
Двусторнние очереди
Очереди с двумя сторонами (или стеки с двумя концами) – двусторнние очереди

В стеке элементы добавлялись только в начало, в очереди – только в конец.
Теперь же ты сможешь добавлять с обеих сторон.
*/

//Работа через библиотеку
#include <deque>
//и класс deque <type>

/*
Работа с деком
имя_дека.front() – возврат значения первого элемента;
имя_дека.back() – возврат значения последнего элемента;
имя_дека.push_front([значение]) – добавление элемента в начало;
имя_дека.push_back([значение]) – добавление элемента в конец;
имя_дека.pop_front() – удаление первого элемента;
имя_дека.pop_back() – удаление последнего элемента;
имя_дека.size() – возврат числа элементов дека;
имя_дека.clear() – очистка дека.
*/